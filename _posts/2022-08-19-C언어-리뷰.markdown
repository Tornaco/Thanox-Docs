---
layout: post
title:  "[자료구조(Data Structure)정리] 1. C언어 리뷰"
date:   2022-08-19
categories: Data Structure
excerpt: "자료구조를 공부하기 전에 자료구조 공부에 필요한 C언어 핵심을 간단하게 리뷰"
---
# C언어 리뷰

OS(운영체제): 컴퓨터 자원 관리, 사용자를 위한 소프트웨어 제공, 사용자-하드웨어간의 인터페이스

C compiler: source → complie → object file → loader(linker) → program

**변수의 유형**

static(정적) / global(전역)

프로그램이 시작될 때 메모리 공간에 할당되고 프로그램이 종료될 때까지 남아있음

전역 변수는 모든 함수에서 접근할 수 있음

정적 변수의 접근 범위(scope)는 해당 변수를 선언한 함수로 제한됨

automatic(자동) / local(지역)

함수 안에서 stack 영역에 선언되는 변수

접근 범위는 함수 내로 제한되고, 함수가 호출되는 동안만 존재

dynamic(동적)

heap 메모리 영역에 할당

메모리 해제 전까지 메모리에 존재

### 메모리 레이아웃

High address →                     ( global, static variables )                          ← Low address
Stack → Heap → Uninitialized Data Segmemt → Initialized Data Segment → Code Segment

배열은 메모리의 연속된 공간에 할당됨

### 포인터

메모리 위치의 주소를 저장하는 변수

**참조 (referencing)** : & operator로 주소 전달

**역참조 (dereferencing)** : * operator로 포인팅하고 있는 값 사용

Void pointer: 어떤 데이터 타입도 참조할 수 있는 범용 포인터

역참조할 때는 형변환(casting)해야 함

배열의 이름은 배열의 첫번째 element를 가리키는 주소

포인터 연산: *(pv+3) == pv[3]

함수 포인터: 다른 함수에 argument로 전달 가능

Call-by-value: 값으로 전달, 복사본이 만들어짐

동적 메모리 할당 관련 함수

void *malloc(size_t size); size만큼의 연속된 메모리블럭을 할당하고 포인터를 반환

void *calloc(size_t nmemb, size_t size); 각 size만큼의 nmemb개의 아이템에 대한 연속된 메모리블럭을 할당하고 0으로 초기화

void *realloc(void *ptr, size_t size); Ptr가 가리키는 메모리의 크기를 size만큼 변화시킴

void free(void *ptr); ptr가 기리키는 메모리블럭을 해제

할당된 메모리는 반드시 해제해야 함

**메모리 누수**: 메모리의 주소를 잃어버리는 경우. free 함수가 호출되지 않은 경우

프로그램이 종료되어도 heap에 할당된 메모리가 반환되지 않음 → 가용 메모리 양 감소 → out of memory 오류 발생

흔한 오류들:

해제된 포인터를 사용(dangling pointer),

Double free

할당 범위를 벗어난 메모리 영역에 접근

가변 길이 배열: 함수 내에서 변수 기반의 크기를 가지는 배열

배열을 위한 메모리 할당이 runtime에 결정됨

함수가 종료될 때 메모리가 자동으로 해제됨

함수는 이 메모리에 대한 포인터를 반환하면 안 됨

크기가 결정된 후에는 크기를 변경할 수 없음
