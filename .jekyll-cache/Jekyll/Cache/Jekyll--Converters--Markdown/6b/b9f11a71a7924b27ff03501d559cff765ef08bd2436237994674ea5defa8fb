I"<h1 id="c언어-리뷰">C언어 리뷰</h1>

<p>OS(운영체제): 컴퓨터 자원 관리, 사용자를 위한 소프트웨어 제공, 사용자-하드웨어간의 인터페이스</p>

<p>C compiler: source → complie → object file → loader(linker) → program</p>

<p><strong>변수의 유형</strong></p>

<p>static(정적) / global(전역)</p>

<p>프로그램이 시작될 때 메모리 공간에 할당되고 프로그램이 종료될 때까지 남아있음</p>

<p>전역 변수는 모든 함수에서 접근할 수 있음</p>

<p>정적 변수의 접근 범위(scope)는 해당 변수를 선언한 함수로 제한됨</p>

<p>automatic(자동) / local(지역)</p>

<p>함수 안에서 stack 영역에 선언되는 변수</p>

<p>접근 범위는 함수 내로 제한되고, 함수가 호출되는 동안만 존재</p>

<p>dynamic(동적)</p>

<p>heap 메모리 영역에 할당</p>

<p>메모리 해제 전까지 메모리에 존재</p>

<h3 id="메모리-레이아웃">메모리 레이아웃</h3>

<p>High address →                     ( global, static variables )                          ← Low address
Stack → Heap → Uninitialized Data Segmemt → Initialized Data Segment → Code Segment</p>

<p>배열은 메모리의 연속된 공간에 할당됨</p>

<h3 id="포인터">포인터</h3>

<p>메모리 위치의 주소를 저장하는 변수</p>

<p><strong>참조 (referencing)</strong> : &amp; operator로 주소 전달</p>

<p><strong>역참조 (dereferencing)</strong> : * operator로 포인팅하고 있는 값 사용</p>

<p>Void pointer: 어떤 데이터 타입도 참조할 수 있는 범용 포인터</p>

<p>역참조할 때는 형변환(casting)해야 함</p>

<p>배열의 이름은 배열의 첫번째 element를 가리키는 주소</p>

<p>포인터 연산: *(pv+3) == pv[3]</p>

<p>함수 포인터: 다른 함수에 argument로 전달 가능</p>

<p>Call-by-value: 값으로 전달, 복사본이 만들어짐</p>

<p>동적 메모리 할당 관련 함수</p>

<p>void *malloc(size_t size); size만큼의 연속된 메모리블럭을 할당하고 포인터를 반환</p>

<p>void *calloc(size_t nmemb, size_t size); 각 size만큼의 nmemb개의 아이템에 대한 연속된 메모리블럭을 할당하고 0으로 초기화</p>

<p>void *realloc(void *ptr, size_t size); Ptr가 가리키는 메모리의 크기를 size만큼 변화시킴</p>

<p>void free(void *ptr); ptr가 기리키는 메모리블럭을 해제</p>

<p>할당된 메모리는 반드시 해제해야 함</p>

<p><strong>메모리 누수</strong>: 메모리의 주소를 잃어버리는 경우. free 함수가 호출되지 않은 경우</p>

<p>프로그램이 종료되어도 heap에 할당된 메모리가 반환되지 않음 → 가용 메모리 양 감소 → out of memory 오류 발생</p>

<p>흔한 오류들:</p>

<p>해제된 포인터를 사용(dangling pointer),</p>

<p>Double free</p>

<p>할당 범위를 벗어난 메모리 영역에 접근</p>

<p>가변 길이 배열: 함수 내에서 변수 기반의 크기를 가지는 배열</p>

<p>배열을 위한 메모리 할당이 runtime에 결정됨</p>

<p>함수가 종료될 때 메모리가 자동으로 해제됨</p>

<p>함수는 이 메모리에 대한 포인터를 반환하면 안 됨</p>

<p>크기가 결정된 후에는 크기를 변경할 수 없음</p>
:ET